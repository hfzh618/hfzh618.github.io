{"pages":[{"title":"about","text":"hufangzhou is very good","link":"/about/index.html"}],"posts":[{"title":"Hexo使用笔记","text":"​ 记录Hexo的使用教程和常用命令。 初始化​ 通过 hexo init 命令来初始化，之后可以加上文件夹名称来制定初始化的文件夹位置，不然默认将会在当前文件夹进行初始化。初始化的目录下不能有任何文件，否则会报错。 文件介绍 _config.yml 文件，配置了博客的各项设置 source 文件夹，里面有所有的博文或是独立页面 themes 文件夹，包含了一个或多个主题文件夹 接下去我来一一详细介绍一下： _config.yml​ 这个文件使用的是 yaml 语法写成的，正常情况下不用掌握任何变成知识也能看懂，注意，# 后的内容是注释，将会被无视。文件中我认为比较重要的是 Site， theme 还有 deploy 这几块。deploy 将在之后讲到部署的时候再提。这里就简单说明一下 Site 和 theme 1title: Hexo # title 的作用是在浏览其中打开时，显示在标签页上的标题subtitle: '' # 副标题在某些主题中会被显示，但更有可能直接无视description: '' # 用于被搜索引擎捕获时告知其站点的基本信息keywords: # 网站关键词author: John Doe # 作者名称，language: en # 网站语言，主要看主题是否支持，同时具体书写方式也因主题而异timezone: '' # 设置时区，中国可以直接写成 Asia/Shanghai ​ 而theme 则是用于设置博客所使用的主题，具体内容需要完全符合 themes 文件夹中主题文件夹的名称。 另外需要提醒的是，yaml 语法中， :（冒号）后面需要加上空格，不然会报错。 source文件夹​ 在一开始，可能其中只有 _posts 文件夹，这里面是用来存放发表后的博文的，之后如果生成过草稿文件，那么会多出来一个 _drafts 文件夹，用于存放草稿，同时如果生成过独立页面，还会生成与页面名称相同的文件夹。 themes文件夹​ 这里面存放了所有的主题，每个主题一个文件夹，具体名称可以随意修改，但修改后一定要修改根目录下的 _config.yml 中 theme 条目，不然会出现错误。 ​ 一开始 Hexo 自带的主题名为 landscape，因此能够在 themes 文件夹下找到同名文件夹。 ​ 之前提到 _config.yml 中的 language 选项，如果在主题文件夹下发现了 languages 文件夹，那么说明这个主题是支持多种语言的。进入该文件夹，就能发现一些 .yml 文件，这时候就需要修改 language 为文件名中的 ，例如有 zh.yml，就需要将 language 修改为 zh，没有 zh 但有 zh_cn 时就需要将 zh 改为 zh_cn 。 新建博文hexo new​ 这个命令是新建一篇博文，具体的使用方法为：hexo new [layout] &lt;title&gt;，其中 layout 为可选项，选择这篇博文的布局，常见的有 post 和 draft 两种，post 会将其放置在 _posts 文件夹中，而 draft 则在 _drafts 中。如果不填写，默认将会选择 post。title 则是必选项，会做为文件名称，生成的文件就是 title.md。 发布博文hexo publish​ 发布命令，会将草稿发布出去，使用方法为 hexo publish [layout] &lt;filename&gt; ，layout 可以选择发布时使用的模板，默认为 post。 则是草稿的文件名，注意不包括后缀名。 启动服务器hexo server​ 这个命令将会启动一个本地服务器，将你的博客暂时可以从本地直接访问，方便查看效果。这个命令执行后，打开浏览器，访问 http://localhost:4000 即可。如果想要停止，按下 ctrl＋c 终止命令。 可被简写为 hexo s 文章写作明白了如何使用 Hexo 生成想要的文件以及如何预览之后，就可以开始进行博文的撰写了。在 source 目录下，可以找到所有生成的文章，可以使用任何喜欢的文本编辑器进行编辑。Hexo 的博文使用的是 markdown 来撰写的，当然也可以插入一些 HTML 代码来进行自定义。 Front-matterHexo 每一篇生成的文章开头都会有一段由两行 「—」包裹起来的内容，称为 Front-matter 1---title: my-test-draftdate: 2020-03-05 13:47:52tags:--- title 指的是博文的标题，默认生成的标题与使用 hexo new 命令中输入的 title 相同，但是可以自行更改。 date 指的是文件被发布的时间，如果是直接生成的时间，那就与生成时间相同，如果是由 draft 通过 hexo publish 命令发布的，那就与 publish 的时间相同。 tags 指的是文章的标签，可以打上多个，如下所示： 1tags: - tag1 - tag2 - tag3 当然如果不需要使用多个 tag 的情况下，可以直接将唯一的 tag 直接加到 tags 后面，就像这样： 1tags: onlyTag 这段内容必须在每篇博文的最顶端，上面可以有空行但是不可以有其他文字，不然会出现错误 其二就是摘要。每一篇生成的博文应该都会出现在 Hexo 的主页上。如果不使用摘要，那么每一篇文章都会全文显示在主页上，这是很不美观，也很浪费资源的一种方式。如果使用摘要，那么主页上只会显示一小段内容，不仅吸引了读者，还能使得整个博客网站更加优雅。摘要必须写在文章开头，紧接着文件头部。当摘要写作完成后，另起一行输入 &lt;!-- more --&gt; 即可，这样上面的内容就能被识别，并显示在主页上。不过，这段摘要同样也会在博文页面中被显示出来，需要注意。 部署本地配置​ 打开本地的 _config.yml，找到 deploy （正常情况下在文件最后），将其修改为： 1234deploy: type: git repo: &lt;刚刚复制下来的内容&gt; branch: master ​ 再找到 URL 下的 url（在文件开头处），将其修改为 12#URLurl: https://&lt;username&gt;.github.io ​ 然后在命令行中，进入博客根目录，输入 yarn add hexo-deployer-git（使用 Yarn）或是 npm install hexo-deployer-git --save （使用 npm）。这样本地配置也就完成了。 hexo generate 与 hexo deploy​ 最后，在命令行中输入 hexo deploy，就会看到非常长的一串输出，结束后就推送完成了。进到 GitHub 页面查看是否大致是这样子的文件结构 ​ 使用 hexo deploy 命令会同时调用 hexo generate 命令，在博客根目录生成一个 public 文件夹，里面的文件就是推送到 GitHub 上的文件。之后想要更新博客内容的话，建议首先使用 hexo clean 命令清除掉 public 文件夹，然后再使用 hexo deploy 推送。 hexo deploy 可被简写为 hexo d ，hexo generate 可被简写为 hexo g ，hexo clean 可被简写为 hexo c 。 主题与插件我在最开始提到了 Hexo具有很强的自定义能力，可以打开 Hexo的官网，顶栏上就有 Themes 和 Plugins 的入口。 要安装主题，首先需要去 Themes 页面找到一款心仪的主题（可以通过点击图片来访问主题的演示站点），然后点击主题的名称进入主题的 GitHub 页面。如果熟悉 Git 的操作，可以通过 git clone 命令将其克隆至博客根目录下的 themes 文件夹，或者通过 GitHub 自带的下载，下载源码的 zip 包，将其解压缩至 themes 文件夹中。 git clone 命令：git clone https://github.com/&lt;username&gt;/&lt;reponame&gt; 每个主题文件夹中，都有着自己的 _config.yml，管理着这个主题的一些配置，因此如果想要切换主题，在下载下来后，一定要到文件夹中去查看 _config.yml 的配置，并进行自己的个性化修改。同时，GitHub 的仓库页面会显示这个仓库的 README.md 文件，这是这个仓库的说明文件，建议在使用这个主题前提前阅读这个文件，并按照说明安装。 而如果是插件，那么就与主题的安装大不相同了。先找到需要的插件，然后再进入到插件的 GitHub 页面，一般在 README.md 中都会详细介绍如何安装。 Hexo 的插件多由 node.js 写成，因此介绍的安装方法基本都是在博客目录下执行 npm install &lt;plugin name&gt; --save 。如果使用 Yarn 安装，那么需要将其改为 yarn add &lt;plugin name&gt; 。当然，很多时候安装插件都需要更改根目录下的 _config.yml 文件，因插件而异。","link":"/2020/08/24/Hexo%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"title":"git fetch &amp; pull的区别","text":"","link":"/2020/08/25/git-fetch-pull%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"Trello教程","text":"本文主要介绍项目管理软件Trello的使用教程 Trello介绍 Trello是由Fog Creek Software开发的一款免费的网络应用程序，常用来作为网络版的项目管理软件。Trello是一个“水平化”应用，即它的使用并不需要专业知识，各行各业的人都可以找到Trello的用途。 Trello的基本形式是“列表的列表”，它可以用作1980年代流行的丰田供应链管理方式看板管理的工具，也可用于维护各种用途的列表或清单形式的资料。 是一种著名的全平台项目管理、任务管理、多人协作工具。 看板介绍 看板 (Kanban) 一词起源于日语，看板管理则源自丰田的“及时生产”（JIT，just-in-time）系统，即利用看板在各工序、各车间、各工厂以及与协作厂之间传送作业命令，使各工序都按照看板所传递的信息执行，以此保证在必需时间制造必需数量的必需产品，最终达到及时化生产的目的。 我们希望即将到来的协作是简洁且透明的，所有信息都能通过一个醒目简单的辐射源影响到所有成员，可以调动大家的积极性和主动性。 基本概念 Trello 看板仅有四个关键组件，但能够实现无限的可能性： 看板看板代表一个项目或是一个信息跟踪之处。无论你是正在推出新网站还是规划假期，Trello 看板都是你组织任务并与同事、家人和朋友合作的好地方。 列表列表可保持卡片 (C) 在进度的各个阶段有序组织。列表可用于创建工作流，卡片可随着工作流从开始到完成在列表之间移动，或仅用作一个跟踪观点和信息的地方。可在看板中添加的列表的数量没有限制，并可随心所欲进行组织。 看板的基本（但有效）列表设置可以是简单的“待办”、“正在办”以及“已完成”，卡片会从“待办”事项列表开始一直到“完成”列表结束。但不要忘记：Trello 真正可根据你的独特需求进行定制，因此，你可以依照自己的喜好对列表进行命名。无论是基本看板、销售渠道、营销日历还是项目管理，最重要的是按照你的团队运作方式建立工作流。 卡片看板的基本单位是卡片。卡片用于代表任务和观点。卡片可以是需要做的事情，如待写的博客帖子，或者需要记住的事情，如公司度假政策。只需点击任何列表底部的“添加卡片”创建新卡片，然后对其进行命名，如“取回干洗的衣物”或“写博客帖子”。 通过点击卡片可对其进行自定义，以便容纳各种实用信息。在列表之间拖放卡片可以显示进度。对可在看板中添加的卡片数量没有限制。 菜单在 Trello 看板的右侧是菜单，也就是看板的任务控制中心。该菜单用于管理成员、控制设置、过滤卡片和启用 Power-Ups。你还可以在菜单的动态订阅源中查看看板上发生的所有动态。 花一些时间查阅菜单提供的所有功能。 深入了解卡片说明卡片说明 — 在说明字段，你可以添加更多有关卡片、网站链接或分步骤指示方面的具体信息。要给卡片添加详细信息，可单击卡片背面顶部的“编辑说明”(Edit the description)。你甚至可以通过Markdown设置你的文字格式 菜单说明Power-Ups - Power-Ups 为你的 Trello 看板增加附加功能和集成。把你依赖的其他应用程序连接至你的看板，从而在一处了解所有信息。下面是几个例子： Google Drive：从卡片背面快速访问文件，无需离开 Trello 即可随时掌控最重要的信息。（同样适用于 Box、Dropbox！） 自定义字段：向卡片添加更多的结构性信息，如成本、预计时间、电话号码等等。这些项目在卡片正面和背面都可以看到。 快捷键 想要快速查看你在看板上的所有卡片？请使用快捷键 Q。 将鼠标悬停在卡片上并按空格键即可将自己添加到卡片中。使用 M 键将其他人添加到卡片中，这样所有任务都不会属于你。 【卡片】从不错过重要日期！使用 D 键添加到期时间。 【卡片】使用 Shift-Enter 将卡片保存起来，然后进入卡片背面。这简直就是买一送一的特别优惠。 【卡片】使用 L 键打开标签菜单，然后使用 F 键过滤这些标签以显示对你最重要的内容。搜索 采用搜索运算符就像一个精细的齿梳，能真正释放 Trello 中的搜索力量。例如，使用 @me 会返回你的所有卡片，due:week 会返回未来七天内到期的所有卡片，label:red 则会返回应用了红色标签的所有卡片，以及更多更多功能。 最重要的是，多个运算符可以串联使用，如 @me due:overdue -list:done 可以显示你的所有过期且并未处于名为“Done（完成）”的列表中的卡片。","link":"/2020/08/28/Trello%E6%95%99%E7%A8%8B/"},{"title":"CMU 15-445645 1.Course Introduction and the Relational Model","text":"CMU数据库课程15-445645系列的第一课笔记 Course Introduction and the Relational Model 写在前面本系列为CMU 15-445/645数据库课程的学习笔记。学习资源如下： 视频 官网 辅导书 本md为第一课Course Introduction and the Relational Model的相关笔记 Course Introduction and the Relational ModelCOURSE OVERVIEW本课程的目标是设计和实现一个面向磁盘的数据库操作系统，而不是一个如何使用和管理数据库的课程。 基本上，我们假设数据库在磁盘上，然后把数据写到磁盘上。 COURSE OUTLINE课程大纲 Relational Databases Storage Execution Concurrency Control Recovery Distributed Databases Potpourri(高级主题) HOMEWORKS &amp; PROJECTS整个课程有5次作业 第一次是SQL。其他的是写在纸上的。 需要自己从头构建数据库的存储管理器。注意只是一个存储管理器，而不是完善的数据库。 使用的编程语言是C++ 17. 最终构建的项目结构为 面向磁盘的存储 Volcano风格的查询处理 可插拔的API 目前不支持SQL DatabaseDatabase are organized collection of inner-related data that models some aspects of the real world. 并不是随机分布在电脑上的零散文件。 数据库是其他电脑应用的核心。 DATABASE MANAGERMENT SYSTEMDBMS是一个允许应用存储和分析数据库中信息的软件 DBMS被设计用来允许定义、创造、查询、更新和管理数据库。 EARLY DBMS数据库应用难以构建和保持。在逻辑层次和物理层次紧耦合。在部署之前必须要知道什么查询将会执行。 RELATIONAL MODEL1970年由Ted Codd提出 数据库三要素： storage database in simple data structures access data through high-level language physical storage left up to implementation 三个部分 Structure （relation和contents的定义） Integrity (确保数据库内容满足约束) Manipulation （如何访问和修改数据库的内容） relation(关系)是包含表示实体的属性的无序集合 tuple(元组)是关系中的属性的集合.其中的值是原子的.特殊的值NULl 主键 PRIMARY KEYA relation’s primary key uniquely identifies a single tuple. Some DBMSs automatically create an internal primary key if you don’t define one. 图中的id作为主键，可以对每一行进行唯一的标识。 数据库中的主键自增方法 SEQUENCE (SQL:2003) AUTO_INCREMENT (MySQL) 外键 FOREIGN KEYS A foreign key specifies that an attribute from one relation has to map to a tuple in another relation. 图中的artist_id和album_id作为外键，关联两个表、 DATA MANIPUL ATION L ANGUAGES (DML)How to store and retrieve information from a database. 包含增删改查等 DATA MODEL A data model is collection of conceptes for describing the data in a database. A schema is a description of a particular collection of data,using a given data model DATA MODEL 示例 Relational &lt;- Most DBMS Key/Value NoSQL Graph NoSQL Document NoSQL Column-family NoSQL Array/Matrix &lt;- Machine Learning Hierarchical &lt;- Rare Network &lt;- Rare 关系代数 REL ATIONAL ALGEBRATed Codd在关系代数中提出了七种基本运算符，这七种是检索和操作关系中元组的基本操作。都是基于set代数。 Each operator takes one or more relations as its inputs and outputs a new relation 可以通过将这些关系操作链接起来形成复杂的查询。 这些操作符包括 Select Projection Union Intersection Difference Product Join SelectChoose a subset of the tuples from a relation that satisfies a selection predicate. predicate 作为过滤器来保留符合条件的元组 可以使用conjunctions/disjunctions组合多种谓词 ProjectionGenerate a relation with tuples that contains only the specified attributes. 可以对属性重新排序 可以操作值 UnionGenerate a relation that contains all tuples that appear in either only one or both input relations. 需要注意union与union all的区别。 Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； Union All：对两个结果集进行并集操作，包括重复行，不进行排序； IntersectionGenerate a relation that contains only the tuples that appear in both of the input relations. DifferenceGenerate a relation that contains only the tuples that appear in the first and not the second of the input relations. Product也被称为笛卡尔积 Generate a relation that contains all possible combinations of tuples from the input relations JoinGenerate a relation that contains all tuples that are a combination of two tuples (one from each input relation) with a common value(s) for one or more attributes. 对应于SQL中的Natural Join 其他的运算符 Rename Assignment Duplicate Elimination Aggregation Sorting Division Conclusion Databases are ubiquitous. Relational algebra defines the primitives for processing queries on a relational database. We will see relational algebra again when we talk about query optimization + execution.","link":"/2020/08/28/CMU-15-445645-1-Course-Introduction-and-the-Relational-Model/"},{"title":"Git使用教程-起步篇","text":"记录git使用的起步篇 写在前面本文章介绍工作中常用的Git场景以及Git原理，使自己熟练使用Git. 学习资源 官网 官网文档起步版本控制版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 集中化的版本控制系统集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）有一个单一的集中管理的服务器，保存所有文件的修订版本。而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。 而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。 这么做最显而易见的缺点是中央服务器的单点故障。 如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 分布式版本控制系统于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 Git是什么直接记录快照，而非差异比较Git 和其它版本控制系统的主要差别在于 Git 对待数据的方法。 从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异。 Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。在Git中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git对待数据更像是一个快照流。 这是Git与几乎所有其它版本控制系统的重要区别。 因此Git重新考虑了以前每一代版本控制系统延续下来的诸多方面。Git更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS。 近乎所有操作都是本地执行在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。 Git保证完整性Git中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。 这个功能建构在Git底层，是构成Git哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git就能发现。 Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git 一般只添加数据你执行的 Git 操作，几乎只往Git数据库中添加数据。 你很难让Git执行任何不可逆操作，或者让它以任何方式清除数据。 未提交更新时有可能丢失或弄乱修改的内容。但是一旦你提交快照到 Git 中， 就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。 这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。 三种状态现在请注意，如果你希望后面的学习更顺利，请记住下面这些关于 Git 的概念。 Git 有三种状态，你的文件可能处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交表示数据已经安全地保存在本地数据库中。 这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git 目录。 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。 基本的 Git 工作流程如下： 在工作区中修改文件。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 如果 Git 目录中保存着特定版本的文件，就属于已提交状态。 如果文件已修改并放入暂存区，就属于已暂存状态。 如果自上次检出后，作了修改但还没有放到暂存区域，就是已修改状态。 Git配置用户信息安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： 12$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com 再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 检查配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 12345678$ git config --listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto...","link":"/2020/09/01/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E8%B5%B7%E6%AD%A5%E7%AF%87/"},{"title":"Git使用教程-基础篇","text":"记录git使用之基础篇 写在前面在学习完本章之后，你应该能够配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit）更改。本章也将向你演示了如何配置 Git 来忽略指定的文件和文件模式、如何迅速而简单地撤销错误操作、如何浏览你的项目的历史版本以及不同提交（commits）之间的差异、如何向你的远程仓库推送（push）以及如何从你的远程仓库拉取（pull）文件。 Git基础获取 Git 仓库通常有两种获取 Git 项目仓库的方式： 将尚未进行版本控制的本地目录转换为 Git 仓库； 从其它服务器 克隆 一个已存在的 Git 仓库。 两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。 在已存在目录中初始化仓库如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中。 如果你还没这样做过，那么不同系统上的做法有些不同： 1$ git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ： 123$ git add *.c$ git add LICENSE$ git commit -m 'initial project version' 克隆现有的仓库如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令。Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库。 克隆仓库的命令是 git clone 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令： 1$ git clone https://github.com/libgit2/libgit2 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名： 1$ git clone https://github.com/libgit2/libgit2 mylibgit 这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。 Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。 记录每次更新到仓库请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。 工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。 编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。 在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。 检查当前文件状态可以用 git status 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出： 1234$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.nothing to commit, working directory clean 这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是“master”,这是默认的分支名。 我们在 Git 分支 中会详细讨论分支和引用。 现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件： 12345678910$ echo 'My Project' &gt; README$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) READMEnothing added to commit but untracked files present (use &quot;git add&quot; to track) 在状态报告中可以看到新建的 README 文件出现在 Untracked files 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。 跟踪新文件使用命令 git add 开始跟踪一个文件。 所以，要跟踪 README 文件，运行： 1$ git add README 此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态： 1234567$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) new file: README 只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 git add 时的版本将被留存在后续的历史记录中。 你可能会想起之前我们使用 git init 后就运行了 git add 命令，开始跟踪当前目录下的文件。git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 暂存已修改的文件现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容： 12345678910111213$ git statusOn branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: READMEChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 文件 CONTRIBUTING.md 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令。这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 状态简览git status 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 git status -s 命令或 git status –short 命令，你将得到一种格式更为紧凑的输出。 123456$ git status -s M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile 文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。 忽略文件一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 来看一个实际的 .gitignore 例子： 123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。 查看已暂存和未暂存的修改如果 git status 命令的输出对于你来说过于简略，而你想知道具体修改了什么地方，可以用 git diff 命令。 稍后我们会详细介绍 git diff，你通常可能会用它来回答这两个问题：当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？ 虽然 git status 已经通过在相应栏下列出文件名的方式回答了这个问题，但 git diff 能通过文件补丁的格式更加具体地显示哪些行发生了改变。 若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff –staged 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异： 请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 git diff 后却什么也没有，就是这个原因。 提交更新现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有 git add 过， 否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit： 1$ git commit 这样会启动你选择的文本编辑器来输入提交说明。 另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行。 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤 1$ git commit -a -m 'added new benchmarks' 移除文件要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到： 下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f（译注：即 force 的首字母）。 另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 –cached 选项： 1$ git rm --cached README 移动文件要在 Git 中对文件改名，可以这么做： 1$ git mv file_from file_to 查看提交历史在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。 当你在此项目中运行 git log 命令时，可以看到下面的输出： 123456789101112131415161718$ git logcommit ca82a6dff817ec66f44342007202690a93763949Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Mon Mar 17 21:52:11 2008 -0700 changed the version numbercommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary testcommit a11bef06a3f659402fe7563abf99ad00de2209e6Author: Scott Chacon &lt;schacon@gee-mail.com&gt;Date: Sat Mar 15 10:31:28 2008 -0700 first commit 不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。 git log 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。 其中一个比较有用的选项是 -p 或 –patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 -2 选项来只显示最近的两次提交： 该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。 你也可以为 git log 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 –stat 选项： 另一个非常有用的选项是 –pretty。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一： 当 oneline 或 format 与另一个 log 选项 –graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史： 1234567891011$ git log --pretty=format:&quot;%h %s&quot; --graph* 2d3acf9 ignore errors from SIGCHLD on trap* 5e3ee11 Merge branch 'master' of git://github.com/dustin/grit|\\| * 420eac9 Added a method for getting the current branch.* | 30e367c timeout code and tests* | 5a09431 add timeout protection to grit* | e1193f8 support for heads with slashes in them|/* d6016bc require time for xmlschema* 11d191e Merge branch 'defunkt' into local 限制输出长度git log 还有许多非常实用的限制输出长度的选项，也就是只输出一部分的提交。 之前你已经看到过 -2 选项了，它只会显示最近的两条提交， 实际上，你可以使用类似 - 的选项，其中的 n 可以是任何整数，表示仅显示最近的 n 条提交。 类似 –since 和 –until 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近两周的所有提交： 1$ git log --since=2.weeks 该命令可用的格式十分丰富——可以是类似 “2008-01-15” 的具体的某一天，也可以是类似 “2 years 1 day 3 minutes ago” 的相对日期。 还可以过滤出匹配指定条件的提交。 用 –author 选项显示指定作者的提交，用 –grep 选项搜索提交说明中的关键字。 另一个非常有用的过滤器是 -S（俗称“pickaxe”选项，取“用鹤嘴锄在土里捡石头”之意）， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用： 1$ git log -S function_name 最后一个很实用的 git log 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。 撤销操作有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令来重新提交： $ git commit –amend这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。 文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作： 123$ git commit -m 'initial commit'$ git add forgotten_file$ git commit --amend 最终你只会有一个提交——第二次提交将代替第一次提交的结果。 取消暂存的文件接下来的两个小节演示如何操作暂存区和工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交， 但是却意外地输入 git add * 暂存了它们两个。如何只取消暂存两个中的一个呢？ git status 命令提示了你： 12345678$ git add *$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) renamed: README.md -&gt; README modified: CONTRIBUTING.md 在 “Changes to be committed” 文字正下方，提示使用 git reset HEAD … 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件： 1$ git reset HEAD CONTRIBUTING.md 撤消对文件的修改如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，git status 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样： 12345Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md 它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行： 1$ git checkout -- CONTRIBUTING.md 如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 Git 分支 介绍保存进度与分支，这通常是更好的做法。 远程仓库的使用远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字： 你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 添加远程仓库我们在之前的章节中已经提到并展示了 git clone 命令是如何自行添加远程仓库的， 不过这里将告诉你如何自己来添加它。 运行 git remote add 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写： 12345678$ git remoteorigin$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push) 从远程仓库中抓取与拉取就如刚才所见，从远程仓库中获得数据，可以执行： 1$ git fetch &lt;remote&gt; 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你的当前分支设置了跟踪远程分支， 那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程分支当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push 。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器： 1$ git push origin master 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 查看某个远程仓库如果想要查看某一个远程仓库的更多信息，可以使用 git remote show 命令。 远程仓库的重命名与移除你可以运行 git remote rename 来修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做： 如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 git remote remove 或 git remote rm 打标签Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建和删除新的标签、以及不同类型的标签分别是什么。 列出标签在 Git 中列出已有的标签非常简单，只需要输入 git tag （可带上可选的 -l 选项 –list）： 123$ git tagv1.0v2.0 你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行： 1$ git tag -l &quot;v1.8.5*&quot; 创建标签Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。 轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。 而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。 附注标签在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 tag 命令时指定 -a 选项： 1$ git tag -a v1.4 -m &quot;my version 1.4&quot; 轻量标签另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： 1$ git tag v1.4-lw 删除标签要删除掉你本地仓库上的标签，可以使用命令 git tag -d 。 例如，可以使用以下命令删除一个轻量标签： 1$ git tag -d v1.4-lw 别名在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试： 1234$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 这意味着，当要输入 git commit 时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。 通常也会添加一个 last 命令，像这样： 1$ git config --global alias.last 'log -1 HEAD' 这样，可以轻松地看到最后一次提交：","link":"/2020/09/01/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"title":"Git使用教程-分支篇","text":"记录git使用之分支篇 Git分支几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。 分支简介为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 快照 。 在进行提交操作时，Git 会保存一个提交对象（commit object）。 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象， 为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交： 12$ git add README test.rb LICENSE$ git commit -m 'The initial commit of my project' 当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。 现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树 对象 （记录着目录结构和 blob 对象索引）以及一个 提交 对象（包含着指向前述树对象的指针和所有提交信息）。 做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。 Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。 分支创建Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令： 1$ git branch testing 这会在当前所在的提交对象上创建一个指针。 那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 在 Git 中，它是一个指针，指向当前所在的本地分支（将 HEAD 想象为当前分支的别名）。在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。 你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 –decorate。 1$ git log --oneline --decorate 分支切换要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去： 1$ git checkout testing 这样 HEAD 就指向 testing 分支了。 那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次： 12$ vim test.rb$ git commit -a -m 'made a change' HEAD 分支随着提交操作自动向前移动。如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看： 1$ git checkout master 这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。 我们不妨再稍微做些修改并提交： 12$ vim test.rb$ git commit -a -m 'made other changes' 现在，这个项目的提交历史已经产生了分叉。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。 你可以简单地使用 git log 命令查看分叉历史。 运行 git log –oneline –decorate –graph –all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。 1234567$ git log --oneline --decorate --graph --all* c2b9e (HEAD, master) made other changes| * 87ab2 (testing) made a change|/* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project 由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？ 分支的新建与合并让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤： 开发某个网站。 为实现某个新的用户需求，创建一个分支。 在这个分支上开展工作。 正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理： 切换到你的线上分支（production branch）。 为这个紧急任务新建一个分支，并在其中修复它。 在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。 切换回你最初工作的分支上，继续工作。 新建分支首先，我们假设你正在你的项目上工作，并且在 master 分支上已经有了一些提交。现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令： 12$ git checkout -b iss53Switched to a new branch &quot;iss53&quot; 它是下面两条命令的简写： 12$ git branch iss53$ git checkout iss53 你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，iss53 分支在不断的向前推进，因为你已经检出到该分支 （也就是说，你的 HEAD 指针指向了 iss53 分支） 12$ vim index.html$ git commit -a -m 'added a new footer [issue 53]' 现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 iss53 的修改混在一起， 你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 master 分支。 但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改， 它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，暂存（stashing） 和 修补提交（commit amending））。现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 master 分支了： 12$ git checkout masterSwitched to branch 'master' 这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。 接下来，你要修复这个紧急问题。 我们来建立一个 hotfix 分支，在该分支上工作直到问题解决： 123456$ git checkout -b hotfixSwitched to a new branch 'hotfix'$ vim index.html$ git commit -a -m 'fixed the broken email address'[hotfix 1fb7853] fixed the broken email address 1 file changed, 2 insertions(+) 你可以运行你的测试，确保你的修改是正确的，然后将 hotfix 分支合并回你的 master 分支来部署到线上。 你可以使用 git merge 命令来达到上述目的： 123456$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) 在合并的时候，你应该注意到了“快进（fast-forward）”这个词。 由于你想要合并的分支 hotfix 所指向的提交 C4 是你所在的提交 C2 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。 现在，最新的修改已经在 master 分支所指向的提交快照中，你可以着手发布该修复了。 关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 hotfix 分支，因为你已经不再需要它了 —— master 分支已经指向了同一个位置。 你可以使用带 -d 选项的 git branch 命令来删除分支： 12$ git branch -d hotfixDeleted branch hotfix (3a0874c). 现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。 123456$ git checkout iss53Switched to branch &quot;iss53&quot;$ vim index.html$ git commit -a -m 'finished the new footer [issue 53]'[iss53 ad82d7a] finished the new footer [issue 53]1 file changed, 1 insertion(+) 你在 hotfix 分支上所做的工作并没有包含到 iss53 分支中。 如果你需要拉取 hotfix 所做的修改，你可以使用 git merge master 命令将 master 分支合并入 iss53 分支，或者你也可以等到 iss53 分支完成其使命，再将其合并回 master 分支。 分支的合并假设你已经修正了 #53 问题，并且打算将你的工作合并入 master 分支。 为此，你需要合并 iss53 分支到 master 分支，这和之前你合并 hotfix 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 git merge 命令： 123456$ git checkout masterSwitched to branch 'master'$ git merge iss53Merge made by the 'recursive' strategy.index.html | 1 +1 file changed, 1 insertion(+) 这和你之前合并 hotfix 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。既然你的修改已经合并进来了，就不再需要 iss53 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。 1$ git branch -d iss53 遇到冲突时的分支合并有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 分支的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突： 1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件： 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: index.htmlno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子： 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突： 123&lt;div id=&quot;footer&quot;&gt;please contact us at email.support@github.com&lt;/div&gt; 上述的冲突解决方案仅保留了其中一个分支的修改，并且 &lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= , 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。 如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。 分支管理git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表： 1234$ git branch iss53* master testing 注意 master 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 这意味着如果在这时候提交，master 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令： 1234$ git branch -v iss53 93b412c fix javascript issue* master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes –merged 与 –no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch –merged： 123$ git branch --merged iss53* master 因为之前已经合并了 iss53 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。 查看所有包含未合并工作的分支，可以运行 git branch –no-merged： 12$ git branch --no-merged testing 这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败： 123$ git branch -d testingerror: The branch 'testing' is not fully merged.If you are sure you want to delete it, run 'git branch -D testing'. 分支开发工作流在本节，我们会介绍一些常见的利用分支进行开发的工作流程。而正是由于分支管理的便捷， 才衍生出这些典型的工作模式，你可以根据项目实际情况选择一种用用看。 长期分支因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。 许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的主题分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。 事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。 主题分支主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。 考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子： 请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。 远程分支远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。 它们以 / 的形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。 如果要与给定的远程仓库同步数据，运行 git fetch 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。 推送当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。 如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push : 1$ git push origin serverfix 下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用.可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上： 1$ git checkout -b serverfix origin/serverfix 跟踪分支从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。 当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b /。 这是一个十分常用的操作所以 Git 提供了 –track 快捷方式： 123$ git checkout --track origin/serverfixBranch serverfix set up to track remote branch serverfix from origin.Switched to a new branch 'serverfix' 如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 拉取当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。 变基在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。 变基的基本操作开发任务分叉到两个不同分支，又各自提交了更新。之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上： 1234$ git checkout experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command 它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 现在回到 master 分支，进行一次快进合并。 12$ git checkout master$ git merge experiment 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁. 请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。 变基的风险 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。 变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。 变基Vs合并总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。","link":"/2020/09/01/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-%E5%88%86%E6%94%AF%E7%AF%87/"},{"title":"CMU 15-445645 第二课","text":"CMU数据库课程15-445645系列的第二课笔记Advanced SQL的笔记 Advanced SQLRelational LanguagesUsers only needs to specify the answer that they want,not how to compute it. The DBMS is reponsible for efficient evalutaion of the query. -&gt; Query optimizer: re-orders operations and generates query plan. Data Manipulation Language（增删改查） Data Definition Language (通过定义schema来创建表存储数据) Data Control Language （安全性授权） also includes view definition Integrity &amp; Referential Constraints Transactions SQL HistoryStructured Query Language Current standard is SQL:2016 SQL 2016 JSON,Ploymorphic tables SQL 2011 Temporal DBs,Pipelined DML SQL 2008 TRUNCATE,Fancy ORDER SQL 2003 XML,windows,sequences,auto-generated IDs SQL 1999 Regex,triggers,OO Most DBMSs at least support SQL-92 today’s agenda aggregations + group by string/date/time operations output control + redirection nested queries common table expressions window functions Example database aggregates 聚合函数functions that return a single value from a bag of tuples: AVG(col) -&gt; return the average col value MIN(col) -&gt; return minimum col value MAX(col) -&gt; return maximum col value SUM(col) -&gt; return sum of col value COUNT(col) -&gt; return # average col value 将多个tuple作为输入，在此基础上计算某种聚合并产生单个结果。 aggregate function只能用于SELECT 输出结果中。 Get # of students with a “@cs” login 12SELECT COUNT(login) AS cntFROM student WHERE login LIKE ‘%@cs’ 还可以有下面这两种写法 12SELECT COUNT(*) AS cntFROM student WHERE login LIKE ‘%@cs’ 12SELECT COUNT(1) AS cntFROM student WHERE login LIKE ‘%@cs’ 写法不同，但是语义相同。 MULTIPLE AGGREGATES可以在单个查询中放入多个聚合函数 Get the number of students and their average GPA that have a “@cs” login. 12SELECT AVG(gpa), COUNT(sid)FROM student WHERE login LIKE '%@cs' DISTINCT AGGREGATESCOUNT, SUM, AVG 聚合函数支持 DISTINCT 12SELECT COUNT(DISTINCT login)FROM student WHERE login LIKE '%@cs' GROUP BYProject tuples into subsets and calculate aggregates against each subset 基于某个属性将我们想要的tuple放在一起。即物以类聚。 1234SELECT AVG(s.gpa), e.cidFROM enrolled AS e, student AS sWHERE e.sid = s.sidGROUP BY e.cid 这个sql的意思是先根据cid进行分组，然后根据学生姓名计算平均GPA 想要从聚合函数中提取信息，使用group by HAVINGFilters results based on aggregation computaion Like a WHERE clause for a GROUP BY 12345SELECT AVG(s.gpa) AS avg_gpa, e.cidFROM enrolled AS e,student AS sWHERE e.sid = s.sidGROUP BY e.cidHAVING avg_gpa &gt; 3.9 HAVING子句对结果进行一次过滤 STRING OPERATIONS所有的字符串都区分大小写。 LIKElike is used for matching. String-matching operators ‘%’ matches any substring ‘_’ matches any one character 123456SELECT * FROM enrolled AS eWHERE e.cid LIKE '15-%'SELECT * FROM student AS sWHERE s.login LIKE '%@c_' funcionsSQL-92 defines string functions can be used in either output and predicates 12345SELECT SUBSTRING(name,0,5) AS abbrv_nameFROM student WHERE sid = 5333SELECT * FROM student AS sWHERE UPPER(e.name) LIKE 'KAN%' ||SQL stanard uses || operator to concatenate two or more strings together 123456\\\\SQL92SELECT name FROM student WHERE login = LOWER(name) || '@cs'\\\\MySQLSELECT name FROM studentWHERE login = CONCAT(LOWER(name), '@cs') DATE/TIME OPERATIONSOperations to manipulate and modify DATE/TIME attributes. Can be used in either output and predicates. Support/syntax varies wildly… Demo: Get the # of days since the beginning of the year. 1234567SELECT CURRENT_TIMESTAMP; //查询当前时间//PostgresSELECT DATE('2018-08-29') - DATE('2018-01-01') AS days //MySQLSELECT DATEDIFF(DATE('2018-08-29') - DATE('2018-01-01')) AS days;//SQLiteSELECT CAST((julianday(CURRENT_TIMESTAMP) - julianday('2018-01-01')) AS INT ) AS days; OUTPUT REDIRECTIONStore query results in another table: Table must not already be defined. Table will have the same # of columns with the same types as the input. 123456// SQL -92SELECT DISTINCT cid INTO CourseIdsFROM enrolled;// MySQLCREATE TABLE CourseIds(SELECT DISTINCT cid FROM enrolled); 把查询结果输出到表格中。 Insert tuples from query into another table: Inner SELECT must generate the same columns as the target table. DBMSs have different options/syntax on what to do with duplicates. 12INSERT INTO CourseIds(SELECT DISTINCT cid FROM enrolled); ORDER BYOrder the output tuples by the values in one or more of their columns. 1234567SELECT sid,grade FROM enrolled WHERE cid = '15-721'ORDER BY gradeSELECT sid FROM enrolled WHERE cid = '15-721'ORDER BY grade DESC,sid ASC ORDER BY的属性没有限制 LIMITLimit the # of tuples returned in output. Can set an offset to return a “range” 1234567SELECT sid, name FROM studentWHERE login LIKE '%@cs'LIMIT 10SELECT sid, name FROM studentWHERE login LIKE '%@cs'LIMIT 20 OFFSET 10 LIMIT查询的是无序的，需要结合order by使其变为有序的 NESTED QUERIED 嵌套查询Queries containing other queries. They are often difficult to optimize. Inner queries can appear (almost) anywhere in query. 正确的方法是使用join进行重写 Get the names of students in ‘15-445 12345SELECT name FROM studentWHERE sid IN ( SELECT sid FROM enrolled WHERE cid = '15-445') 这里的sid查询了两次，需要优化查找方案。 操作符 ALL→ Must satisfy expression for all rows in subquery ANY→ Must satisfy expression for at least one row in sub-query. IN→ Equivalent to ‘=ANY()’ . EXISTS→ At least one row is returned. Find student record with the highest id that is enrolled in at least one course. 12345678910SELECT sid, name FROM studentWHERE sid IN ( SELECT MAX(sid) FROM enrolled)SELECT sid, name FROM studentWHERE sid IN ( SELECT sid FROM enrolled ORDER BY sid DESC LIMIT 1) Find all courses that has no students enrolled in it. 12345SELECT * FROM courseWHERE NOT EXISTS( SELECT * FROM enrolled WHERE course.cid = enrolled.cid) WINDOW FUNCTIONSPerforms a “sliding” calculation across a set of tuples that are related. Like an aggregation but tuples are not grouped into a single output tuples. Aggregation functions: Anything that we discussed earlier MIN MAX AVG SUM Special window functions: ROW_NUMBER()→ # of the current row RANK()→ Order position of the current row 12SELECT *,ROW_NUMBER() OVER() AS row_numFROM enrolled overThe OVER keyword specifies how to group together tuples when computing the window function. Use PARTITION BY to specify group. 1234SELECT cid, sid,ROW_NUMBER() OVER (PARTITION BY cid)FROM enrolledORDER BY cid You can also include an ORDER BY in the window grouping to sort entries in each group. 1234SELECT *,ROW_NUMBER() OVER (ORDER BY cid)FROM enrolledORDER BY cid COMMON TABLE EXPRESSIONSProvides a way to write auxiliary statements for use in a larger query. → Think of it like a temp table just for one query. Alternative to nested queries and views. You can bind output columns to names before the AS keyword. 1234WITH cteName (col1, col2) AS (SELECT 1, 2)SELECT col1 + col2 FROM cteName Find student record with the highest id that is enrolled in at least one course. 12345WITH cteSource (maxId) AS ( SELECT MAX(sid) FROM enrolled)SELECT name FROM student, cteSourceWHERE student.sid = cteSource.maxId Print the sequence of numbers from 1 to 10. Demo: Postgres CTE! 1234567WITH RECURSIVE cteSource (counter) AS ( (SELECT 1) UNION ALL (SELECT counter + 1 FROM cteSource WHERE counter &lt; 10) ) SELECT * FROM cteSourc","link":"/2020/09/05/CMU-15-445645-2-Advanced%20SQL/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Trello","slug":"Trello","link":"/tags/Trello/"},{"name":"Database","slug":"Database","link":"/tags/Database/"}],"categories":[]}